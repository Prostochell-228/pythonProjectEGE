def A():
    with open('./files/27A_9757.txt') as f:
        a = list(map(int, f.read().strip().split('\n')))
        k = a[0]
        a = a[2:]
    m = 0

    for x in range(0, len(a) - k - k):
        for y in range(x + k, len(a) - k):
            for z in range(y + k, len(a)):
                h = a[x] * a[y] * a[z]
                if h > m and h % 2023 == 0:
                    m = h
    print(m)


g = [(1, 1, 2023), (1, 7, 289), (1, 17, 119), (1, 2023, 1), (7, 1, 289), (7, 17, 17), (17, 1, 119), (17, 7, 17),
     (17, 17, 7), (2023, 1, 1)]


def B():  # сложное говно
    with open('./files/27B_9757.txt') as f:  # открываем файлик
        ak = list(map(int, f.read().strip().split('\n')))  # читаем файлик создаём список интов
        k = ak[0]  # Выбираем минимальное расстояние между 2мя значениями
        ak = ak[2:]  # Убираем условие
    maxi = 0  # задаём переменную для максимума
    for q, w, e in g:  # Интересный перебор который распокоувает из скобок смотреть G
        a1 = list(map(lambda x: x * (x % q == 0), ak))  # Все которые не делятся на Q превращает в 0
        a2 = list(map(lambda x: x * (x % w == 0), ak))  # Все которые не делятся на W превращает в 0
        a3 = list(map(lambda x: x * (x % e == 0), ak))  # Все которые не делятся на E превращает в 0
        b = [0 for i in
             range(k)]  # Создаём список который хранит максимально возможные перемножения второго и третьего чисел
        while a3[len(b) + k:]:  # Заполняет БЭ смотреть выше
            m = max(
                a3[len(b) + k:])  # Находи максимально возможные значения из нерассмотренных значений A3 смотреть вышле
            mi = len(a3) - a3[::-1].index(m) - 1  # находит последний индес вхождения m  в A3
            for i in a2[len(b):mi - k + 1]:  # Перебирает все возможные значения второго чимла с учётом отступа К
                b.append(m * i)  # Заполняет список БЭ
        c = []  # Адское перемножение всего треш жест
        while b[len(c) + k:]:  # Заполнет ЦЭ смотреть выше
            m = max(
                b[len(c) + k:])  # Находи максимально возможные значения из нерассмотренных значений БЭ смотреть вышле
            mi = len(b) - b[::-1].index(m) - 1  ##находит последний индес вхождения m  в БЭ
            for i in a1[len(c):mi - k + 1]:  # Перебирает все возможные значения первого чимла с учётом отступа К
                if (m * i) % 2023 == 0:  # Проверка адского перемноженияя я на делимость АДСКАЯ ПРОВЕРКА
                    h = m * i  # ЗАДАЁМ ПРЕМНОЖЕНИЕ
                else:  # В ДРУГООООООООООООООООООООООООООМ СЛУЧАЕ
                    h = 0  # НУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУУЛЬ
                c.append(h)  # ЗАполняем этим ЦЭ
        maxi = max(max(c), maxi)  # Проверияем на максимальность
    print(maxi)  # 


A()
B()
